@page "/foldertree/folderitem/{RepoName}"
@using BlazorMonaco.Editor
@using Radzen
@using AutoMapper
@using Microsoft.Extensions.Logging
@using TFGDevopsApp.Common
@using TFGDevopsApp.Components.Pages.Code
@using TFGDevopsApp.Core.Models.Result
@using TFGDevopsApp.Dtos.Plastic.Repositories
@using TFGDevopsApp.Dtos.Plastic.Workspaces
@using TFGDevopsApp.Interfaces
@using TFGDevopsApp.Core.Models.Plastic
@using System.Linq
@using TFGDevopsApp.Dtos.FolderTree
@inject IPlasticServices plasticServices
@inject IConfiguration configuration
@inject IMapper _mapper
@inject ILogger<FolderItem> _logger
@using Radzen.Blazor


<div class="container">
    <div class="row">
        <div class="col-6">
            <div class="rz-grid-table-cell">
             <RadzenPanel>
                <RadzenTree Data="@FolderTrees"
                            TextProperty="FolderTree.Name"
                            ChildItemsProperty="FolderTree.Children"
                            Expand=@LoadDataAsync
                            Change=@OnNodeChange>
                    <RadzenTreeItem Text="@RepoName">
                        @foreach (var repo in FolderTrees)
                        {
                            <RadzenTreeItem Text="@repo.Name" Expand=@LoadDataAsync>
                                @* Recursive function to display the folder tree *@
                                @BuildTreeView(repo)
                            </RadzenTreeItem>
                        }
                    </RadzenTreeItem>
                </RadzenTree>
            </RadzenPanel>
            </div>
        </div>
        <div class="col-6">
            <div class="rz-grid-table-cell">
                <RadzenPanel>
                   <div class="row">
                        <div class="col-6">
                            <RadzenText>
                                <h4>@CodeFileName</h4>
                            </RadzenText>
                        </div>
                        <div class="col-6">
                            <RadzenButton Text="Solicitar Revisión" Click="@(() => SolicitarRevision())" />
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-12">
                            @if (IsFile)
                            {
                                @* <StandaloneCodeEditor Id="codeReviewId"
                                  ConstructionOptions="EditorConstructionOptions" /> *@
                                @*   <RadzenTextArea Value="@CodeFileContent">
                                  </RadzenTextArea> *@
                             }
                            else
                            {
                                <RadzenPanel Text="Seleccione un archivo para ver su contenido">
                                </RadzenPanel>
                            }
                        </div>
                    </div>
                </RadzenPanel>
            </div>
        </div>
    </div>
</div>
   

@code {

    [Parameter]
    public string RepoName { get; set; }

    private string CodeFileContent  { get; set; }

    private string CodeFileName { get; set; }

    private bool IsFile { get; set; }

    private string CurrentPath { get; set; }

    private List<RepositoryWorkspace> Repositories { get; set; } = new List<RepositoryWorkspace>();

    private List<FolderTree> FolderTrees { get; set; } = new();
    private List<FolderTree> AllFolderTrees { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        var pathPlasticService = configuration.GetValue<string>(Constants.PlasticBaseUrlKey);
        var basePath = $"{pathPlasticService}api/v1/repos/{RepoName}";
        var fileBasePath = $"{basePath}/branches/main/contents";
        var path = fileBasePath;
        //var repos = await plasticServices.GetRepositoryAsync(basePath);
        var data = await plasticServices.GetFolderTreeAsync(path);
        //FolderTrees.AddRange(data.Data.Children);
        FolderTrees = data.Data.Children;
        CurrentPath = path;

        await LoadDataAsync(new TreeExpandEventArgs() { Value = FolderTrees });
        //LoadSubTrees(FolderTrees, null);
    }

    private void SolicitarRevision()
    {

    }


    private StandaloneEditorConstructionOptions EditorConstructionOptions(StandaloneCodeEditor editor)
    {
        return new StandaloneEditorConstructionOptions
            {
                AutomaticLayout = true,
                Language = "csharp",
                Value = CodeFileContent
            };
    }

    private void LoadSubTrees(List<FolderTree> nodes, int? revisionId)
    {
        // Get all nodes that are children of the current parentId
        var children = nodes.Where(x => x.RevisionId == revisionId).ToList();

        foreach (var child in children)
        {
            // Recursively load subtrees for each child
            LoadSubTrees(nodes, child.RevisionId);

            // Find the parent node and add this child to its Children list
            var parent = nodes.FirstOrDefault(x => x.Id == revisionId);
            if (parent != null)
            {
                parent.Children.Add(child);
            }
        }
    }



    private bool ExcludeFiles(string path, List<string>? excludeFiles)
    {
        bool result = excludeFiles.Exists(x => path.Contains(x));
        return result;
    }

    private RenderFragment BuildTreeView(FolderTree tree) => builder =>
     {
         builder.OpenComponent<RadzenTreeItem>(0);
         builder.AddAttribute(1, "Text", tree.Path);
         builder.AddAttribute(2, "Value", tree);
         builder.AddAttribute(3, "Expand", EventCallback.Factory.Create<TreeExpandEventArgs>(this, LoadDataAsync));
         //builder.AddAttribute(4, "Selected", EventCallback.Factory.Create<TreeEventArgs>(this, OnNodeSelected));
         int sequence = 5;
         if (tree.Children != null && tree.Children.Count > 0)
         {
             builder.AddAttribute(4, "ChildContent", (RenderFragment)((builder2) =>
             {
                 foreach (var child in tree.Children)
                 {
                     builder2.AddContent(sequence++, BuildTreeView(child));
                 }
             }));
         }

         builder.CloseComponent();
     };


    private async Task LoadDataAsync(TreeExpandEventArgs args)
    {
        var items = args.Value as List<FolderTree>;

        foreach(var item in items)
        {
            // Perform the necessary action when the tree item is expanded
            if ( item == null ||  item.Children.Count == 0)
            {
                item.Children = await LoadChildrenAsync(item); 
            }
        }
    }

    private async void OnNodeChange(TreeEventArgs args)
    {
        FolderTree selectedNode = args.Value as FolderTree;

        if (selectedNode != null)
        {
            var currentTree = await LoadChildrenAsync(selectedNode);

            FolderTrees = currentTree;
        }
    }


    private async void OnNodeSelected(TreeEventArgs args)
    {
        FolderTree selectedNode = args.Value as FolderTree;

        if (selectedNode != null && selectedNode.Type == "file") //Is a tree leaf.
        {
            var content = await GetFileContentAsync(selectedNode);
            FolderTrees = new List<FolderTree>()
            {
                new FolderTree()
                {
                    Path = selectedNode.Path,
                    Name = selectedNode.Name,
                    Type = selectedNode.Type,
                    ParentTree = selectedNode.ParentTree,
                    Content = content
                }
            };
            IsFile = !string.IsNullOrEmpty(content);    
            CodeFileContent = content;
        }

        if (selectedNode != null && selectedNode.Type == "directory")
        {
            var currentTree = await LoadChildrenAsync(selectedNode);
            FolderTrees = currentTree;
            CurrentPath += selectedNode.Children.Count != 0 ? selectedNode.Path : string.Empty;
            _logger.LogError($"CurrentPath: {CurrentPath}");
        }
    }

    private void OnNodeExpand(TreeExpandEventArgs args)
    {
        var expandedNode = args.Value as FolderTree;
        if (expandedNode != null)
        {
            // Handle the node expand event
            Console.WriteLine($"Expanded node: {expandedNode.Name}");
        }
    }

    private async Task<string> GetFileContentAsync(FolderTree item)
    {
        var pathPlasticService = configuration.GetValue<string>(Constants.PlasticBaseUrlKey);
        var basePath = $"{pathPlasticService}api/v1/repos/{RepoName}";
        var fileBasePath = $"{basePath}/branches/main/contents";
        string path;
        if(!item.Path.Contains(RepoName))
            path = $"{fileBasePath}{item.Path}";
        else
            path = $"{fileBasePath}";

        var fileContent = await plasticServices.GetFolderTreeAsync(path);
        if (!string.IsNullOrEmpty(fileContent.Data.Content))
        {
            var codeContent = await plasticServices.GetFileContentAsyc(fileContent.Data.Content);
            return await Task.FromResult(codeContent);
        }

        return await Task.FromResult(string.Empty);
    }

    private async Task<List<FolderTree>> LoadChildrenAsync(FolderTree item)
    {
        ResultMessage<FolderTree> folderTree = new ResultMessage<FolderTree>();

        if (item != null)
        {
            var pathPlasticService = configuration.GetValue<string>(Constants.PlasticBaseUrlKey);
            var basePath = $"{pathPlasticService}api/v1/repos/{RepoName}";
            var fileBasePath = $"{basePath}/branches/main/contents";
            string path = $"{fileBasePath}{item.Path}";

            folderTree = await plasticServices.GetFolderTreeAsync(path);
            IsFile = folderTree.Data.Type == "file";
        }
        else
            folderTree =  await Task.FromResult(folderTree);

        return folderTree?.Data.Children;
    }
  
    private class RepositoryWorkspace
    {
        public RepositoryResponseDto Repository { get; set; }
        public WorkspaceResponseDto Workspace { get; set; }
        public FolderTree Tree { get; set; }
    }
}
